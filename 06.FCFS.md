```
#!/usr/bin/bash

echo -n "Enter number of processes: "
read n

declare -a pid at bt ct tat wt completed exec_order

# Input arrival time and burst time
for ((i=0; i<n; i++)); do
    pid[$i]=$((i+1))
    echo -n "Enter Arrival Time for P$((i+1)): "
    read at[$i]
    echo -n "Enter Burst Time for P$((i+1)): "
    read bt[$i]
    completed[$i]=0
done

# Optional: Sort processes by arrival time to make scanning simpler (bubble sort)
for ((i=0; i<n-1; i++)); do
    for ((j=0; j<n-i-1; j++)); do
        if (( at[j] > at[j+1] )); then
            # swap arrival time
            tmp=${at[j]}; at[j]=${at[j+1]}; at[j+1]=$tmp
            # swap burst time
            tmp=${bt[j]}; bt[j]=${bt[j+1]}; bt[j+1]=$tmp
            # swap pid
            tmp=${pid[j]}; pid[j]=${pid[j+1]}; pid[j+1]=$tmp
            # swap completed flag (keep consistency)
            tmp=${completed[j]}; completed[j]=${completed[j+1]}; completed[j+1]=$tmp
        fi
    done
done

# SJF non-preemptive scheduling
current_time=0
count=0

# If there is a gap before first arrival, advance time to first arrival
if (( n > 0 )); then
    # ensure current_time starts at earliest arrival (optional)
    if (( current_time < at[0] )); then
        current_time=${at[0]}
    fi
fi

while [ $count -lt $n ]; do
    # find the ready process (arrival <= current_time and not completed) with minimum burst
    min_bt=999999999
    min_index=-1
    for ((i=0; i<n; i++)); do
        if (( completed[i] == 0 )) && (( at[i] <= current_time )); then
            if (( bt[i] < min_bt )); then
                min_bt=${bt[i]}
                min_index=$i
            fi
        fi
    done

    if [ $min_index -

```
